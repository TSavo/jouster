import path from 'path';\nimport { SetupWizard } from '../../wizard/setup-wizard';\n\n// Mock fs, path, child_process, and readline\njest.mock('fs', () => ({\n  constants: {\n    R_OK: 4,\n    W_OK: 2,\n  },\n  promises: {\n    access: jest.fn(),\n    readFile: jest.fn(),\n    writeFile: jest.fn(),\n    mkdir: jest.fn(),\n  },\n  readFile: jest.fn(),\n  writeFile: jest.fn(),\n  access: jest.fn(),\n  mkdir: jest.fn(),\n}));
\n// Mock util.promisify to return the original function\njest.mock('util', () => ({\n  promisify: jest.fn((fn) => fn),\n}));\n\njest.mock('child_process', () => ({\n  execSync: jest.fn(),\n}));\n\njest.mock('readline', () => ({\n  createInterface: jest.fn(() => ({\n    question: jest.fn((question, callback) => callback('y')),\n    close: jest.fn(),\n  })),\n}));
\ndescribe('SetupWizard', () => {\n  const mockProjectRoot = '/mock/project/root';\n  let wizard: SetupWizard;\n  \n  beforeEach(() => {\n    jest.clearAllMocks();\n    wizard = new SetupWizard(mockProjectRoot, false);\n  });\n  \n  describe('detectEnvironment', () => {\n    it('should detect Jest configuration', async () => {\n      // Mock fs.access to simulate finding jest.config.js\n      const fs = require('fs');\n      (fs.promises.access as jest.Mock).mockImplementation((filePath) => {\n        if (filePath === path.join(mockProjectRoot, 'jest.config.js')) {\n          return Promise.resolve();\n        }\n        return Promise.reject(new Error('File not found'));\n      });
\n      // Mock fs.readFile to return a mock Jest config\n      (fs.promises.readFile as jest.Mock).mockResolvedValue(\n        module.exports = {\n          testMatch: ['**/*.test.js'],\n          testEnvironment: 'node',\n        };\n      );\n      \n      // Call the private method using any type assertion\n      await (wizard as any).detectEnvironment();\n      \n      // Verify that the Jest config was detected\n      expect((wizard as any).config.jestConfigPath).toBe(path.join(mockProjectRoot, 'jest.config.js'));\n      expect((wizard as any).config.jestConfigType).toBe('js');\n    });\n    \n    it('should detect GitHub CLI', async () => {\n      // Mock execSync to simulate GitHub CLI being installed\n      const { execSync } = require('child_process');\n      (execSync as jest.Mock).mockImplementation((command) => {\n        if (command === 'gh --version') {\n          return Buffer.from('gh version 2.0.0');\n        }\n        throw new Error('Command not found');\n      });
\n      // Call the private method using any type assertion\n      await (wizard as any).detectEnvironment();\n      \n      // Verify that GitHub CLI was detected\n      expect((wizard as any).config.hasGitHubCLI).toBe(true);\n    });\n    \n    it('should detect GitHub token', async () => {\n      // Mock process.env to include a GitHub token\n      const originalEnv = process.env;\n      process.env = { ...originalEnv, GITHUB_TOKEN: 'mock-token' };\n      \n      // Call the private method using any type assertion\n      await (wizard as any).detectEnvironment();\n      \n      // Verify that GitHub token was detected\n      expect((wizard as any).config.hasGitHubToken).toBe(true);\n      \n      // Restore original process.env\n      process.env = originalEnv;\n    });\n    \n    it('should detect test patterns', async () => {\n      // Mock fs.access to simulate finding a test directory\n      const fs = require('fs');\n      (fs.promises.access as jest.Mock).mockImplementation((filePath) => {\n        if (filePath === path.join(mockProjectRoot, '__tests__')) {\n          return Promise.resolve();\n        }\n        return Promise.reject(new Error('Directory not found'));\n      });
\n      // Call the private method using any type assertion\n      await (wizard as any).detectEnvironment();\n      \n      // Verify that test directory was detected\n      expect((wizard as any).config.testDir).toBe(path.join(mockProjectRoot, '__tests__'));\n    });\n    \n    it('should detect package.json', async () => {\n      // Mock fs.access to simulate finding package.json\n      const fs = require('fs');\n      (fs.promises.access as jest.Mock).mockImplementation((filePath) => {\n        if (filePath === path.join(mockProjectRoot, 'package.json')) {\n          return Promise.resolve();\n        }\n        return Promise.reject(new Error('File not found'));\n      });\n      \n      // Call the private method using any type assertion\n      await (wizard as any).detectEnvironment();\n      \n      // Verify that package.json was detected\n      expect((wizard as any).config.packageJsonPath).toBe(path.join(mockProjectRoot, 'package.json'));\n    });\n  });
\n  describe('generateConfiguration', () => {\n    beforeEach(() => {\n      // Set up config with mock values\n      (wizard as any).config = {\n        jestConfigPath: path.join(mockProjectRoot, 'jest.config.js'),\n        jestConfigType: 'js',\n        hasGitHubCLI: true,\n        hasGitHubToken: false,\n        testPatterns: ['**/*.test.js'],\n        testDir: path.join(mockProjectRoot, '__tests__'),\n        packageJsonPath: path.join(mockProjectRoot, 'package.json'),\n      };\n      \n      // Mock fs.readFile to return mock content\n      const fs = require('fs');\n      (fs.promises.readFile as jest.Mock).mockImplementation((filePath) => {\n        if (filePath.endsWith('jest.config.js')) {\n          return Promise.resolve(\n            module.exports = {\n              testMatch: ['**/*.test.js'],\n              testEnvironment: 'node',\n            };\n          );\n        } else if (filePath.endsWith('package.json')) {\n          return Promise.resolve(JSON.stringify({\n            name: 'mock-project',\n            version: '1.0.0',\n            scripts: {\n              test: 'jest',\n            },\n            devDependencies: {\n              jest: '^29.0.0',\n            },\n          }));\n        }\n        return Promise.reject(new Error('File not found'));\n      });
